/*
 * Copyright (c) 2012 Dmitri Melikyan
 *
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the 
 * "Software"), to deal in the Software without restriction, including 
 * without limitation the rights to use, copy, modify, merge, publish, 
 * distribute, sublicense, and/or sell copies of the Software, and to permit 
 * persons to whom the Software is furnished to do so, subject to the 
 * following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN 
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


var url = require('url');
var util = require('util');
var zlib = require('zlib');
var request = require('request');
var EventEmitter = require('events').EventEmitter;
var redis;


var Server = function(opts) {
  redis || (redis = require('redis'));

  var self = this;

  this.version = '0.1.1';

  opts = opts || {};
  this.redis = opts.redis || {port: 6379, host: "127.0.0.1"};
  this.ttl = opts.ttl || 60;
  this.debug = opts.debug;


  this._outgoing = new EventEmitter();
  this._outgoing.setMaxListeners(200);

  this._db = redis.createClient(this.redis.post, this.redis.host); 
  this._db.on("error", function (err) {
    self.error(err);
  });
  this._db.info();

  var pubsub = redis.createClient(this.redis.post, this.redis.host);
    pubsub.on("error", function (err) {
      self.error(err);
  });

  pubsub.subscribe("agent.io");
  pubsub.on("message", function(channel, message) {
    var frame = JSON.parse(message.toString());
    self._outgoing.emit(frame.group, frame.msg);
  });


  EventEmitter.call(this);
};

util.inherits(Server, EventEmitter);
exports.Server = Server; 


Server.prototype.log = function(msg) {
  if(this.debug) console.log(msg);
};


Server.prototype.error = function(msg) {
  console.error(msg, msg ? msg.stack : undefined);
};


// relying on express for now
Server.prototype.middleware = function() {
  var self = this;

  return function(req, res, next) {
    var path = url.parse(req.url).pathname;
    var group = req.param("group");

    if(path.match(/^\/agent.io\/push/)) {
      parseBody(req, function(err, body) {
        if(err) {
          self.error(err);
          next();
          return;
        }

        self._push(req, res, group, body);
      });
    }
    else if(path.match(/^\/agent.io\/poll/)) {
      var since = req.param("since");
      self._poll(req, res, group, since);
    }
    else {
      next();
    }
  };
}


// relying on express for now
Server.prototype._return = function(res, ret) {
  this.log("returning result to client");
  res.send(JSON.stringify(ret), {"Content-Type": "application/json"});
};


Server.prototype._push = function(req, res, group, msgs, context) {
  var self = this;

  process.nextTick(function() {
    try {
      var payloads = [];

      msgs.forEach(function(msg) {
        if(msg && msg.payload && msg.ts) {
          payloads.push(msg.payload);

          self.log("message from client " + group)

          self.emit('message', group, msg.payload, req);
          self.emit(group, msg.payload, req);
        }
        else {
          self.error("invalid message from client " + group);
        }
      });

      self.emit('messages', group, payloads, req);
    }
    catch(err) {
      self.error(err);
    }
  });
  
  self._return(res, {});
}


Server.prototype.send = function(group, payload) {
  var self = this;

  this._time(function(err, ts) {
    if(err) return self.error(err);

    var msg = {payload: payload, ts: ts};
    self._db.zadd('agent.io:outgoing:' + group, msg.ts, JSON.stringify(msg), function(err) {
      self._db.publish('agent.io', JSON.stringify({group: group, msg: msg}));
    });

    // cleanup
    self._db.zremrangebyscore('agent.io:outgoing' + group, '-inf', ts - self.ttl * 1000, function(err) {
      if(err) self.error(err);
    });

    self._db.expire('agent.io:outgoing:' + group, self.ttl, function(err) {
      if(err) self.error(err);
    });
  });
};


Server.prototype._poll = function(req, res, group, since) {   
  var self = this;

  since = since || (new Date().getTime() - this.ttl * 1000);

  this._db.zrangebyscore('agent.io:outgoing:' + group, since + 1, '+inf', function(err, stored) {
    if(err) {
      return error(res, err);
    }

    var msgs = [];
    if(stored && stored.length > 0) {
      stored.forEach(function(msg) {
        msgs.push(JSON.parse(msg));
      });
    }

    if(msgs.length > 0) {
      self.log("messages exist for client " + group);
      return self._return(res, msgs);
    }

    var timeoutId = undefined;

    var msgListener = function(msg) {
      clearTimeout(timeoutId);

      self.log("message event for client " + group);
      self._return(res, [msg]);
    };

    timeoutId = setTimeout(function() {
      self._outgoing.removeListener(group, msgListener);

      self.log("message poll timeout for client " + group);
      self._return(res, []);
    }, 60000);

    self._outgoing.once(group, msgListener);

    self.log("waiting for server message for " + group  + " ...");
  });
};


Server.prototype._time = function(callback) {   
  var version = this._db.server_info.versions;

  if(version && version[0] >=2 && version[1] >= 6) {
    this._db.time(function(err, sec, msec) {
      if(err) return callback(err);
      callback(null, Math.round(sec * 1000 + msec / 1000));
    });
  }
  else {
    callback(null, new Date().getTime());
  } 
};

function parseBody(req, callback) {
  var buf = new Buffer(0);

  req.on('data', function(chunk) { 
    buf = Buffer.concat([buf, chunk]);
  });

  req.on('end', function() {
    if(req.headers['content-encoding'] === 'gzip') {
      zlib.gunzip(buf, function(err, buf) {
        if(err) return callback(err);

        callback(null, JSON.parse(buf.toString('utf8')));
      });
    }
    else {
      callback(null, JSON.parse(buf.toString('utf8')));
    }
  });
};
